import{cQ as c}from"./index-e3V0CD7Y.js";import{c as f}from"./cache.service-D8Mcd249.js";const d={auth:{endpoint:{baseURL:"/api/auth",timeout:3e4,retries:2},tokenKey:"supabase.auth.token",refreshTokenKey:"supabase.auth.refresh_token"}};class y{constructor(){this.limiters=new Map,setInterval(()=>this.cleanup(),6e4)}getKey(e,t){return`${e}:${t}`}getLimiter(e){return this.limiters.has(e)||this.limiters.set(e,new Map),this.limiters.get(e)}cleanup(){const e=Date.now();for(const[t,r]of this.limiters.entries()){for(const[n,a]of r.entries())e>a.resetTime&&r.delete(n);r.size===0&&this.limiters.delete(t)}}async checkLimit(e,t,r,n){const a=this.getLimiter(e),o=this.getKey(t,r),h=Date.now(),u=h+n.windowMs;let s=a.get(o);(!s||h>s.resetTime)&&(s={count:0,resetTime:u},a.set(o,s));const l=s.count<n.maxRequests,T=Math.max(0,n.maxRequests-s.count);return l&&s.count++,{allowed:l,resetTime:s.resetTime,remaining:T}}}const p=new y;class R{constructor(){this.authToken=null,this.refreshToken=null,this.isRefreshing=!1,this.failedQueue=[],this.loadTokens()}loadTokens(){this.authToken=localStorage.getItem(d.auth.tokenKey),this.refreshToken=localStorage.getItem(d.auth.refreshTokenKey)}saveTokens(e,t){this.authToken=e,localStorage.setItem(d.auth.tokenKey,e),t&&(this.refreshToken=t,localStorage.setItem(d.auth.refreshTokenKey,t))}clearTokens(){this.authToken=null,this.refreshToken=null,localStorage.removeItem(d.auth.tokenKey),localStorage.removeItem(d.auth.refreshTokenKey)}async refreshAccessToken(){if(!this.refreshToken)throw new Error("No refresh token available");try{const e=await this.makeRequest({method:"POST",url:`${d.auth.endpoint.baseURL}/refresh`,data:{refreshToken:this.refreshToken}},!1),{accessToken:t,refreshToken:r}=e.data;return this.saveTokens(t,r),t}catch(e){throw this.clearTokens(),console.warn("Token refresh failed, clearing authentication"),e}}async handleTokenRefresh(){if(this.isRefreshing)return new Promise((e,t)=>{this.failedQueue.push({resolve:e,reject:t})});this.isRefreshing=!0;try{const e=await this.refreshAccessToken();return this.failedQueue.forEach(({resolve:t})=>t(e)),this.failedQueue=[],e}catch(e){throw this.failedQueue.forEach(({reject:t})=>t(e)),this.failedQueue=[],this.clearTokens(),e}finally{this.isRefreshing=!1}}buildUrl(e,t,r){if(t.startsWith("http")){const a=t;if(r){const o=new URLSearchParams;Object.entries(r).forEach(([u,s])=>{s!=null&&o.append(u,String(s))});const h=o.toString();if(h)return`${a}${a.includes("?")?"&":"?"}${h}`}return a}const n=e?`${e}${t}`:t;if(r){const a=new URLSearchParams;Object.entries(r).forEach(([h,u])=>{u!=null&&a.append(h,String(u))});const o=a.toString();if(o)return`${n}${n.includes("?")?"&":"?"}${o}`}return n}async makeRequest(e,t=!0,r=1){const n=`req_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;try{if(e.method==="GET"&&e.cache?.key){const i=f.get("http_cache",e.cache.key);if(i)return c.debug(`Cache hit for ${e.method} ${e.url}`,{requestId:n}),i}if(e.rateLimit&&!(await p.checkLimit(e.rateLimit.endpoint||"api",e.rateLimit.identifier||"default",e.url,{maxRequests:100,windowMs:6e4})).allowed){const m=new Error("Rate limit exceeded");throw m.status=429,m.isRetryable=!0,m}const a={"Content-Type":"application/json","X-Request-ID":n,...e.headers};t&&this.authToken&&(a.Authorization=`Bearer ${this.authToken}`),c.apiRequest(e.method,e.url,e.data,{requestId:n});const o=this.buildUrl("",e.url,e.params);console.log(`Making ${e.method} request to: ${o}`,{hasAuth:!!a.Authorization,method:e.method});const h=new AbortController,u=setTimeout(()=>h.abort(),e.timeout||3e4),s=await fetch(o,{method:e.method,headers:{...a},body:["GET","HEAD"].includes(e.method)?void 0:e.data?JSON.stringify(e.data):void 0,signal:h.signal});console.log(`Response status: ${s.status} ${s.statusText}`),clearTimeout(u);let l;s.headers.get("content-type")?.includes("application/json")?l=await s.json():l=await s.text();const k={data:l,status:s.status,statusText:s.statusText,headers:Object.fromEntries(s.headers.entries()),config:e};if(s.status===401&&t)try{return await this.handleTokenRefresh(),this.makeRequest(e,t,r)}catch(i){throw c.error("Token refresh failed",i,{requestId:n}),i}if(s.status===403){const i=new Error(`Access denied: ${s.statusText}`);throw i.status=s.status,i.statusText=s.statusText,i.response={data:l,status:s.status,statusText:s.statusText},i.config=e,i.isRetryable=!1,c.error("Access denied (403)",i,{requestId:n,url:e.url}),i}if(!s.ok){const i=new Error(`HTTP ${s.status}: ${s.statusText}`);throw i.status=s.status,i.statusText=s.statusText,i.response={data:l,status:s.status,statusText:s.statusText},i.config=e,i.isRetryable=s.status>=500||s.status===429,i}return c.apiResponse(e.method,e.url,s.status,l,{requestId:n}),e.method==="GET"&&e.cache?.key&&f.set("http_cache",e.cache.key,k,e.cache.ttl,e.cache.tags),k}catch(a){let o;a instanceof Error?(o=a,o.isRetryable=a.message.includes("Failed to fetch")||a.message.includes("Network error")||a.message.includes("timeout")):(o=new Error("Unknown error"),o.isRetryable=!0),c.apiError(e.method,e.url,o,{requestId:n,attempt:r});const h=e.retries||0;if(r<=h&&o.isRetryable){const u=Math.pow(2,r-1)*1e3;return c.info(`Retrying request in ${u}ms`,{requestId:n,attempt:r}),await new Promise(s=>setTimeout(s,u)),this.makeRequest(e,t,r+1)}throw o}}async get(e,t,r){return this.makeRequest({method:"GET",url:e,params:t,...r})}async post(e,t,r){return this.makeRequest({method:"POST",url:e,data:t,...r})}async put(e,t,r){return this.makeRequest({method:"PUT",url:e,data:t,...r})}async patch(e,t,r){return this.makeRequest({method:"PATCH",url:e,data:t,...r})}async delete(e,t){return this.makeRequest({method:"DELETE",url:e,...t})}setAuth(e,t){this.saveTokens(e,t)}clearAuth(){this.clearTokens()}isAuthenticated(){return!!this.authToken}}const x=new R;export{x as h};
