import{cR as A}from"./index-e3V0CD7Y.js";var o={};class u{constructor(){this.threads=new Map}async getOrCreateThread(s,t,i){const e=`${s}_${t}`;if(this.threads.has(e))return this.threads.get(e);const a=await this.createAssistantThread(s,t,i);return this.threads.set(e,a),a}async addMessageToThread(s,t,i,e){const a=Array.from(this.threads.values()).find(n=>n.id===s);a&&(a.lastInteraction=new Date,a.messageCount++,await this.syncThreadAcrossApps(a))}async createAssistantThread(s,t,i){const e=await fetch("/api/openai/assistants/threads",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({entityType:s,entityId:t,context:i})});if(!e.ok)throw new Error(`Failed to create assistant thread: ${e.statusText}`);const a=await e.json();if(!a.success)throw new Error(a.error||"Failed to create assistant thread");return{id:a.threadId,type:s,entityId:t,assistantId:this.getAssistantIdForEntity(s),lastInteraction:new Date,messageCount:0,context:i||{}}}async syncThreadAcrossApps(s){const t=["pipeline-intelligence","contact-analytics","deal-insights","task-automation"];for(const i of t)try{await fetch(`/api/remote-sync/${i}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({thread:s})})}catch(e){console.warn(`Failed to sync thread to ${i}:`,e)}}getAssistantIdForEntity(s){return{contact:o.VITE_CONTACT_ASSISTANT_ID,deal:o.VITE_DEAL_ASSISTANT_ID,task:o.VITE_TASK_ASSISTANT_ID,pipeline:o.VITE_PIPELINE_ASSISTANT_ID}[s]||"default_assistant"}async callAssistantThread(s,t,i,e){try{const a=await fetch("/api/openai/assistants/chat",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({message:s,assistantId:t,threadId:i,context:e})});if(!a.ok)throw new Error(`Assistant chat failed: ${a.statusText}`);const n=await a.json();if(!n.success)throw new Error(n.error||"Assistant chat failed");return{result:n.response,model:"gpt-4o-assistant",confidence:90,threadId:n.threadId,runId:n.runId}}catch(a){throw console.error("Assistant thread call failed:",a),a}}}const h=new u;class T{constructor(){this.assistants=A,this.activeAssistants=new Map,this.initialized=!1}async initialize(){if(!this.initialized)try{await this.loadPersistedAssistants(),await this.ensureSpecializedAssistants(),this.initialized=!0}catch(s){console.error("Failed to initialize persistent assistant service:",s)}}async loadPersistedAssistants(){try{const s=await this.assistants.listAssistants();for(const t of s.data){const i={id:t.id,name:t.name||"Unnamed Assistant",type:this.getAssistantType(t.name||""),instructions:t.instructions||"",activeThreads:new Map,totalInteractions:0,lastUsed:new Date(t.created_at*1e3),performance:{averageResponseTime:2e3,successRate:.95,userSatisfaction:4.5}};this.activeAssistants.set(t.id,i)}}catch(s){console.warn("Could not load existing assistants:",s)}}async ensureSpecializedAssistants(){const s=["contact","deal","task","pipeline"];for(const t of s)if(!Array.from(this.activeAssistants.values()).find(e=>e.type===t))try{const e=await this.assistants.createSpecializedAssistant(t),a={id:e.id,name:e.name||`${t} Assistant`,type:t,instructions:e.instructions||"",activeThreads:new Map,totalInteractions:0,lastUsed:new Date,performance:{averageResponseTime:2e3,successRate:1,userSatisfaction:5}};this.activeAssistants.set(e.id,a),this.setAssistantIdForType(t,e.id)}catch(e){console.error(`Failed to create ${t} assistant:`,e)}}getAssistantType(s){const t=s.toLowerCase();return t.includes("contact")?"contact":t.includes("deal")?"deal":t.includes("task")?"task":t.includes("pipeline")?"pipeline":"general"}setAssistantIdForType(s,t){const i=`VITE_${s.toUpperCase()}_ASSISTANT_ID`;localStorage.setItem(i,t)}async getOrCreateThread(s,t,i){this.initialized||await this.initialize();const e=Array.from(this.activeAssistants.values()).find(n=>n.type===s);if(!e)throw new Error(`No ${s} assistant available`);let a=e.activeThreads.get(t);return a||(a=(await h.getOrCreateThread(s,t,i)).id,e.activeThreads.set(t,a)),{threadId:a,assistantId:e.id}}async chatWithPersistentAssistant(s,t,i,e){const a=Date.now();try{const{threadId:n,assistantId:c}=await this.getOrCreateThread(s,t,e),d=await this.assistants.chatWithAssistant(i,c,n,e),r=this.activeAssistants.get(c);if(r){r.totalInteractions++,r.lastUsed=new Date;const p=Date.now()-a;r.performance.averageResponseTime=r.performance.averageResponseTime*.9+p*.1}return await h.addMessageToThread(n,"user",i,e),await h.addMessageToThread(n,"assistant",d.response,e),{response:d.response,threadId:d.threadId,assistantId:c,persistentMemory:!0}}catch(n){throw console.error("Persistent assistant chat failed:",n),n}}async streamChatWithPersistentAssistant(s,t,i,e){const{threadId:a,assistantId:n}=await this.getOrCreateThread(s,t,e);return this.assistants.streamChatWithAssistant(i,n,a,e)}async getAssistantMemory(s,t,i=50){try{const{threadId:e}=await this.getOrCreateThread(s,t);return(await this.assistants.getMessages(e,i)).data.map(n=>({role:n.role,content:Array.isArray(n.content)?n.content[0]?.text?.value||"":n.content,timestamp:new Date(n.created_at*1e3)}))}catch(e){return console.error("Failed to get assistant memory:",e),[]}}getAssistantStats(){return Array.from(this.activeAssistants.values())}async createCustomAssistant(s){const t=await this.assistants.createAssistant(s),i={id:t.id,name:s.name,type:s.type||"general",instructions:s.instructions,activeThreads:new Map,totalInteractions:0,lastUsed:new Date,performance:{averageResponseTime:2e3,successRate:1,userSatisfaction:5}};return this.activeAssistants.set(t.id,i),t.id}}const f=new T;export{f as persistentAssistantService};
